using System;
using System.Linq;
using Kiota.Builder.CodeDOM;
using Kiota.Builder.Extensions;

namespace Kiota.Builder.Writers.AL;
public class CodeClassDeclarationWriter : BaseElementWriter<ClassDeclaration, ALConventionService>
{
    // TODO-SF: add "Implements" to ClassDeclaration-objects in ALRefiner
    public static string AutoGenerationHeader => "// <auto-generated/>";
    public CodeClassDeclarationWriter(ALConventionService conventionService) : base(conventionService) { }
    public override void WriteCodeElement(ClassDeclaration codeElement, LanguageWriter writer)
    {
        var alWriter = writer as ALWriter;
        ArgumentNullException.ThrowIfNull(codeElement);
        ArgumentNullException.ThrowIfNull(alWriter);
        if (codeElement.ParentIsSkipped()) return;
        if (codeElement.Parent is not CodeClass parentClass) throw new InvalidOperationException($"The provided code element {codeElement.Name} doesn't have a parent of type {nameof(CodeClass)}");
        if (parentClass.Parent is not CodeNamespace)
        {
            // seems to be a nested class, we don't support that in AL
            ((IDocumentedElement)codeElement.Parent).AddCustomProperty("skip", "true");
            return;
        }
        if (codeElement.Parent?.Parent is CodeNamespace)
        {
            alWriter.WriteLine(AutoGenerationHeader);
            alWriter.WriteLine($"namespace {codeElement.Parent.Parent.Name};");
            alWriter.WriteLine();
            codeElement.Usings
                    .Where(x => (x.Declaration?.IsExternal ?? true) || !x.Declaration.Name.Equals(codeElement.Name, StringComparison.OrdinalIgnoreCase)) // needed for circular requests patterns like message folder
                    .Select(static x => x.Declaration?.IsExternal ?? false ?
                                    $"using {x.Declaration.Name.NormalizeNameSpaceName(".")};" :
                                    $"using {x.Name.NormalizeNameSpaceName(".")};")
                    .Distinct(StringComparer.Ordinal)
                    .OrderBy(static x => x, StringComparer.Ordinal)
                    .ToList()
                    .ForEach(x => alWriter.WriteLine(x));
            alWriter.WriteLine();
        }
        var derivedTypes = (codeElement.Inherits is null ? Enumerable.Empty<string?>() : new string?[] { conventions.GetTypeString(codeElement.Inherits, parentClass) })
                                        .Union(codeElement.Implements.Select(static x => $"\"{x.Name}\""))
                                        .OfType<string>()
                                        .ToArray();
        var derivation = derivedTypes.Length != 0 ? "implements " + derivedTypes.Aggregate(static (x, y) => $"{x}, {y}") : string.Empty;
        var customProperties = parentClass.GetCustomProperties(); // save custom properties
        parentClass.RemoveCustomProperties(); // remove custom properties
        bool hasDescription = conventions.WriteLongDescription(parentClass, alWriter);
        conventions.WriteDeprecationAttribute(parentClass, alWriter);
        parentClass.SetCustomProperties(customProperties); // restore custom properties

        alWriter.WriteLine($"codeunit {alWriter.ObjectIdProvider.GetNextCodeunitId()} {codeElement.GetShortName().ToFirstCharacterUpperCase()} {derivation}");
        alWriter.StartBlock();
        alWriter.WriteObjectProperties(parentClass.ObjectProperties().ToObjectProperties());
        alWriter.WriteVariablesDeclaration(parentClass.OrderedGlobalVariables(), parentClass);
    }
}
