/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.microsoft.kiota.core;

import java.io.IOException;
import java.io.InputStream;
import java.lang.UnsupportedOperationException;
import java.time.OffsetDateTime;
import java.util.Map;
import java.util.Objects;
import java.util.StringJoiner;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

import com.microsoft.kiota.RequestInfo;
import com.microsoft.kiota.ResponseHandler;
import com.microsoft.kiota.AuthenticationProvider;
import com.microsoft.kiota.core.serialization.JsonParseNodeFactory;
import com.microsoft.kiota.core.serialization.ParseNodeFactoryRegistry;
import com.microsoft.kiota.serialization.Parsable;
import com.microsoft.kiota.serialization.ParseNode;
import com.microsoft.kiota.serialization.ParseNodeFactory;

import okhttp3.MediaType;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.ResponseBody;
import okio.BufferedSink;

public class HttpCore implements com.microsoft.kiota.HttpCore {
    private final static String authorizationHeaderKey = "Authorization";
    private final static String contentTypeHeaderKey = "Content-Type";
    private final OkHttpClient client;
    private final AuthenticationProvider authProvider;
    private final ParseNodeFactory pNodeFactory;
    public HttpCore(@Nonnull final AuthenticationProvider authenticationProvider){
        this(authenticationProvider, null, null);
    }
    public HttpCore(@Nonnull final AuthenticationProvider authenticationProvider, @Nonnull final ParseNodeFactory parseNodeFactory) {
        this(authenticationProvider, parseNodeFactory, null);
        Objects.requireNonNull(parseNodeFactory, "parameter parseNodeFactory cannot be null");
    }
    public HttpCore(@Nonnull final AuthenticationProvider authenticationProvider, @Nullable final ParseNodeFactory parseNodeFactory, @Nullable final OkHttpClient client) {
        this.authProvider = Objects.requireNonNull(authenticationProvider, "parameter authenticationProvider cannot be null");
        if(client == null) {
            this.client = new OkHttpClient.Builder().build();
        } else {
            this.client = client;
        }
        if(parseNodeFactory == null) {
            final ParseNodeFactoryRegistry registry = new ParseNodeFactoryRegistry();
            registry.contentTypeAssociatedFactories.put("application/json", new JsonParseNodeFactory());
            pNodeFactory = registry;
        } else {
            pNodeFactory = parseNodeFactory;
        }

    }
    @Nonnull
    public <ModelType extends Parsable> CompletableFuture<ModelType> sendAsync(@Nonnull final RequestInfo requestInfo, @Nonnull final Class<ModelType> targetClass, @Nullable final ResponseHandler responseHandler) {
        Objects.requireNonNull(requestInfo, "parameter requestInfo cannot be null");

        return addBearerIfNotPresent(requestInfo).thenCompose(x -> {
            final HttpCoreCallbackFutureWrapper wrapper = new HttpCoreCallbackFutureWrapper();
            this.client.newCall(getRequestFromRequestInfo(requestInfo)).enqueue(wrapper);
            return wrapper.future;
        }).thenCompose(response -> {
            if(responseHandler == null) {
                final ResponseBody body = response.body();
                try {
                    try (final InputStream rawInputStream = body.byteStream()) {
                        final ParseNode rootNode = pNodeFactory.getParseNode(getMediaTypeAndSubType(body.contentType()), rawInputStream);
                        final ModelType result = rootNode.getObjectValue(targetClass);
                        return CompletableFuture.completedStage(result);
                    }
                } catch(IOException ex) {
                    return CompletableFuture.failedFuture(new RuntimeException("failed to read the response body", ex));
                } finally {
                    response.close();
                }
            } else {
                return responseHandler.handleResponseAsync(response);
            }
        });
    }
    private String getMediaTypeAndSubType(final MediaType mediaType) {
        return mediaType.type() + "/" + mediaType.subtype();
    }
    @Nonnull
    public <ModelType> CompletableFuture<ModelType> sendPrimitiveAsync(@Nonnull final RequestInfo requestInfo, @Nonnull final Class<ModelType> targetClass, @Nullable final ResponseHandler responseHandler) {
        return addBearerIfNotPresent(requestInfo).thenCompose(x -> {
            final HttpCoreCallbackFutureWrapper wrapper = new HttpCoreCallbackFutureWrapper();
            this.client.newCall(getRequestFromRequestInfo(requestInfo)).enqueue(wrapper);
            return wrapper.future;
        }).thenCompose(response -> {
            if(responseHandler == null) {
                final ResponseBody body = response.body();
                try {
                    if(targetClass == Void.class) {
                        return CompletableFuture.completedStage(null);
                    } else {
                        final InputStream rawInputStream = body.byteStream();
                        if(targetClass == InputStream.class) {
                            return CompletableFuture.completedStage((ModelType)rawInputStream);
                        }
                        final ParseNode rootNode = pNodeFactory.getParseNode(getMediaTypeAndSubType(body.contentType()), rawInputStream);
                        rawInputStream.close();
                        if(targetClass == Boolean.class) {
                            return CompletableFuture.completedStage((ModelType)rootNode.getBooleanValue());
                        } else if(targetClass == String.class) {
                            return CompletableFuture.completedStage((ModelType)rootNode.getStringValue());
                        } else if(targetClass == Integer.class) {
                            return CompletableFuture.completedStage((ModelType)rootNode.getIntegerValue());
                        } else if(targetClass == Float.class) {
                            return CompletableFuture.completedStage((ModelType)rootNode.getFloatValue());
                        } else if(targetClass == Long.class) {
                            return CompletableFuture.completedStage((ModelType)rootNode.getLongValue());
                        } else if(targetClass == UUID.class) {
                            return CompletableFuture.completedStage((ModelType)rootNode.getUUIDValue());
                        } else if(targetClass == OffsetDateTime.class) {
                            return CompletableFuture.completedStage((ModelType)rootNode.getOffsetDateTimeValue());
                        } else {
                            throw new RuntimeException("unexpected payload type " + targetClass.getName());
                        }
                    }
                } catch(IOException ex) {
                    return CompletableFuture.failedFuture(new RuntimeException("failed to read the response body", ex));
                } finally {
                    response.close();
                }
            } else {
                return responseHandler.handleResponseAsync(response);
            }
        });
    }
    private CompletableFuture<Void> addBearerIfNotPresent(final RequestInfo requestInfo) {
        if(!requestInfo.headers.keySet().contains(authorizationHeaderKey)) {
            return this.authProvider
                .getAuthorizationToken(requestInfo.uri)
                .thenApply(token -> {
                    if(token == null || token.isEmpty()) {
                        throw new UnsupportedOperationException("Could not get an authorization token", null);
                    }
                    requestInfo.headers.put(authorizationHeaderKey, "Bearer " + token);
                    return null;
                });
        } else {
            return CompletableFuture.completedFuture(null);
        }
    }
    private Request getRequestFromRequestInfo(@Nonnull final RequestInfo requestInfo) {
        final StringBuilder urlBuilder = new StringBuilder(requestInfo.uri.toString());

        if(!requestInfo.queryParameters.isEmpty()) {
            urlBuilder.append('?');
            final StringJoiner qParamsJoiner = new StringJoiner("&");
            for (final Map.Entry<String, Object> qPram : requestInfo.queryParameters.entrySet()) {
                final Object value = qPram.getValue();
                final String valueStr = value == null ? "" : value.toString();
                qParamsJoiner.add(qPram.getKey() + (valueStr.isEmpty() ? "" : "=") + valueStr);
            }
            urlBuilder.append(qParamsJoiner.toString());
        }
        final RequestBody body = requestInfo.content == null ? null :
                                new RequestBody() {
                                    @Override
                                    public MediaType contentType() {
                                        final String contentType = requestInfo.headers.containsKey(contentTypeHeaderKey) ? requestInfo.headers.get(contentTypeHeaderKey) : "";
                                        if(contentType.isEmpty()) {
                                            return null;
                                        } else {
                                            return MediaType.parse(contentType);
                                        }
                                    }

                                    @Override
                                    public void writeTo(BufferedSink sink) throws IOException {
                                        sink.write(requestInfo.content.readAllBytes());
                                        //TODO this is dirty and is probably going to use a lot of memory for large payloads, loop on a buffer instead
                                    }

                                };
        final Request.Builder requestBuilder = new Request.Builder()
                                            .url(urlBuilder.toString())
                                            .method(requestInfo.httpMethod.toString(), body);
        for (final Map.Entry<String,String> header : requestInfo.headers.entrySet()) {
            requestBuilder.addHeader(header.getKey(), header.getValue());
        }
        return requestBuilder.build();
    }
}
